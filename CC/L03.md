 
 
 int num = 123;
    double d = 45.67;

    string s1 = to_string(num);  // "123"
    string s2 = to_string(d);    // "45.670000" (default precision)


   Count Ones (Set Bits)



# Built-in Bit Counting Functions

## **GCC/Clang Built-ins** (Fastest)

### **Count Ones:**
```cpp
int x = 0b11010101;

__builtin_popcount(x);      // 32-bit integers
__builtin_popcountl(x);     // long integers  
__builtin_popcountll(x);    // long long integers
```

### **Count Zeros:**
```cpp
// Leading zeros (from MSB)
__builtin_clz(x);      // 32-bit
__builtin_clzl(x);     // long
__builtin_clzll(x);    // long long

// Trailing zeros (from LSB)
__builtin_ctz(x);      // 32-bit
__builtin_ctzl(x);     // long  
__builtin_ctzll(x);    // long long
```

### **Parity:**
```cpp
__builtin_parity(x);   // 1 if odd number of ones, 0 otherwise
```

## **C++20 Standard** (Portable)
```cpp
#include <bit>

std::popcount(x);          // Count ones
std::countl_zero(x);       // Count leading zeros  
std::countr_zero(x);       // Count trailing zeros
std::countl_one(x);        // Count leading ones
std::countr_one(x);        // Count trailing ones
```

## **Example:**
```cpp
unsigned int num = 0b11010101; // 213

cout << __builtin_popcount(num);   // 5 ones
cout << __builtin_clz(num);        // 26 leading zeros (in 32-bit)
cout << __builtin_ctz(num);        // 0 trailing zeros

// Total zeros = 32 - 5 = 27
```

**These are the fastest methods as they use CPU instructions directly!**



Sum is possible by 

   int total = accumulate(begin(arr), end(arr), 0);




