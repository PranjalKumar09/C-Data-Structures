# ðŸ”¹ C++ STL & Combinatorics Notes (Refined)

---

## 1. Custom Sorting

```cpp
bool comp(string a, string b) {
    if (a.size() != b.size()) return a.size() < b.size();
    return a < b;
}

sort(v.begin(), v.end(), comp);
```

* Sorts strings by **length first**, then **lexicographically**.

---

## 2. Binary Search Utilities

* `lower_bound(arr, arr+n, x)` â†’ pointer to first element **â‰¥ x**.
* `upper_bound(arr, arr+n, x)` â†’ pointer to first element **> x**.
* `equal_range(arr, arr+n, x)` â†’ returns both lower and upper bounds.

**Check if element exists:**

```cpp
auto k = lower_bound(arr, arr+n, x) - arr;
if (k < n && arr[k] == x) {
    // x found at index k
}
```

**Count occurrences of x:**

```cpp
auto a = lower_bound(arr, arr+n, x);
auto b = upper_bound(arr, arr+n, x);
cout << b - a << "\n";

// Using equal_range
auto r = equal_range(arr, arr+n, x);
cout << r.second - r.first << "\n";
```

---

## 3. Multiset

```cpp
multiset<int> s; // allows multiple instances
s.erase(5);       // removes all 5s
s.erase(s.find(5)); // removes only one instance
```

---

## 4. Reversing & Shuffling

**Vector:**

```cpp
reverse(v.begin(), v.end());
random_shuffle(v.begin(), v.end());
```

**Array:**

```cpp
reverse(a, a+n);
random_shuffle(a, a+n);
```

---

## 5. Bitset

```cpp
bitset<10> s;
s[4] = 1;
cout << s[4] << " " << s[5] << "\n"; // 1 0

bitset<10> s2(string("0010011010")); // from right to left
cout << s2.count() << "\n";          // number of ones
```

**Bitwise operations:**

```cpp
bitset<10> a("0010110110"), b("1011011000");
cout << (a & b) << "\n"; // AND
cout << (a | b) << "\n"; // OR
cout << (a ^ b) << "\n"; // XOR
```

* Bitset uses **less memory** than ordinary arrays.

---

## 6. Priority Queue

```cpp
priority_queue<int, vector<int>, greater<int>> pq; // min-heap
```

---

## 7. Subset Generation

**Binary representation method:**

```cpp
for (int b = 0; b < (1 << n); b++) {
    vector<int> subset;
    for (int i = 0; i < n; i++) {
        if (b & (1 << i)) subset.push_back(i);
    }
}
```

*Recursion method (take/not take) is also possible.*

---

## 8. Permutations

**Recursive approach:**

```cpp
void search() {
    if (permutation.size() == n) {
        // process permutation
    } else {
        for (int i = 0; i < n; i++) {
            if (chosen[i]) continue;
            chosen[i] = true;
            permutation.push_back(i);
            search();
            chosen[i] = false;
            permutation.pop_back();
        }
    }
}
```

**Using `next_permutation`:**

```cpp
vector<int> permutation(n);
for (int i = 0; i < n; i++) permutation[i] = i;

do {
    // process permutation
} while (next_permutation(permutation.begin(), permutation.end()));
```

*Example permutations of {0,1,2}:*

```
(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)
```

---

