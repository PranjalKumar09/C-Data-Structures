
its risky to compare floating code, by ==, ,due to variable floating points

it can compare by 

if (abs(d1, d2) < 1e-9)...
  


## Shortening code

typedef long long ll;

even like th9is
typedef vector<int> vi;


Another way using macros (certain string changed to something)

#define F first
#define S second
#define PB push_back
#define MP make_pair

these define called macros


v.push_back(make_pair(y, x));
int d = v[i].first + v[i].second;

change to 
v.PB(MP(y, x));
int d = v[i].F + v[i].S;



even like this 
#define REP(i, a, b) for (int  i = a; i <= b>)




type names


typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pi;





sum of square => (n(n+1)(2n+1))/6




a + ak + ak^2 ... + b
geometric progression sum -> (bk - a)/(k-1)



time complexity
O(n!) (factorial time) is significantly slower than O(2^n) (exponential time)





maximum sum of array
    we have to take maximum of maximum sum ending at that position

    cur_max = max(arr[i], arr[i]+cur_max);
    maxi = max(cur_max,maxi);




Reverse sort 
sort(v.rbegin(),v.rend())

or use 

    sort(begin(arr), end(arr), greater<int>());




ordinary array can we sorted 
int n = 7; // array size
int a[] = {4,2,5,3,5,8,3};
sort(a,a+n);




and string is nothing but vector of char
so sorting done as like array



vector<pair<int,int>> v;
sort(v.begin(), v.end());


Pairs (pair) are sorted primarily according to their first elements (first).
However, if the first elements of two pairs are equal, they are sorted according to
their second elements (second)
Similarly tuple too

vector<pair<int,int>> v;
vector<tuple<int,int,int>> v;



